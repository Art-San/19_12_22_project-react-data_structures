/* eslint-disable react/no-unescaped-entities */
import Title from 'app/components/common/typografy/title'
import diagrama1 from 'app/assets/img/diagrams/slaid2-1.png'
// import Subtitle from 'app/components/common/typografy/subtitle'
// import SmallTitle from 'app/components/common/typografy/smallTitle'
import Text from 'app/components/common/typografy/text'
import { CodeBlock, dracula } from 'react-code-blocks'
// import diagram from 'app/assets/img/diagrams/One-To-Many.jpg'
import {
    productReviews,
    gettingDenormalizedObject,
    denormalizedObject

} from './examples'
import React from 'react'
import SmallTitle from 'app/components/common/typografy/smallTitle'
const OneToManyPage1 = () => {
    return (
        <>
            <Title>Тип связи "один ко многим" (one to many)</Title>
            <Text>
                В прошлой части мы разобрались с тем, что такое связь в базе данных,
                разобрались с типом связи “один к одному” и остановились на примере
                с отзывами о товаре.
            </Text>
            <img
                src={diagrama1}
                style={{
                    width: '100%',
                    borderRadius: '10px'
                }}
            />
            <Text>
                На схеме мы видим, что сущность “Товар”
                связана с отзывами. Но у товара может
                быть множество отзывов, следовательно,
                наш товар связан с несколькими записями
                в таблице отзывы.
            </Text>
            <Text>
               В формате JSON можно представить вот так:
            </Text>
            <CodeBlock
                text={productReviews}
                language="js"
                theme={dracula}
                wrapLines={true}
            />
            <Text>
                Связь “один ко многим” является наиболее
                распространенной среди типов связи.
                В такого рода связях строка в таблице “А”
                может иметь много связанных строк в таблице “B”.
                Но строка в таблице “B” может иметь только одну
                связанную строку в таблице “А”. Например, в нашей таблице
                “Отзывы” у одной записи связь может быть только
                с одной записью в таблице “Товары”,
                тогда как у товара может быть связь со многими отзывами.
            </Text>
            <Text>
                Давай представим, как нам получить денормализованный
                объект с товарами и их отзывами для нашего примера:
            </Text>
            <CodeBlock
                text={gettingDenormalizedObject}
                language="js"
                theme={dracula}
                wrapLines={true}
            />
            <Text>
                В результате мы получим:
            </Text>
            <CodeBlock
                text={denormalizedObject}
                language="js"
                theme={dracula}
                wrapLines={true}
            />
            <Text>
                Хочется заметить, что в данном случае мы не храним
                ссылку на отзывы в продукте. Если бы мы так сделали,
                то нам бы пришлось каждый раз записывать новую ссылку,
                когда пользователь напишет новый отзыв. А так как записи
                о товарах используются чаще, чем отзывы, то это приводило
                бы к снижению производительности. Такое отношение между
                сущностями называется восходящее, когда у нас указатель
                храниться в дочерней сущности.
            </Text>
            <Text>
                Так же существует нисходящее отношение. Это когда связь
                хранится внутри родительской сущности. Оно тоже допускается
                для использования, если это соответствует вашим целям.
                Невозможно определить абсолютно правильный или неправильный
                способ хранения, не учитывая контекста задачи проекта.
            </Text>
            <Text>
                Можно подытожить и сказать какие цели помогает достичь
                создание связи “один ко многим”.
            </Text>
            <SmallTitle>Зачем нужна связь “один ко многим”</SmallTitle>
            <li>Для увеличения производительности</li>
            <li>Для согласованности данных</li>
            <SmallTitle>Зачем это знать во Frontend-разработке</SmallTitle>
            <Text>
                Способы хранения данных на Frontend аналогичны Backend,
                и иногда при изменении данных (например по API) мы не
                всегда получаем новые данные от сервера. Сервер может
                ответить на запрос изменения просто “OK status 200”,
                и не всегда целесообразно делать новый запрос
                за получением обновленных данных.
                Однако в этот момент мы должны показать
                изменения на странице пользователю.
                Для этого мы должны работать с нашим хранилищем
                данных и уметь точечно изменять нужные поля.
            </Text>
            <Text>
                Кроме того, часто при разработке API для экономии
                ресурсов сервера, разработчики создают endpoint’ы
                (конкретные методы API), руководствуясь
                правилом — делать так, чтобы можно было быстро
                получать данные из БД, передавать по сети и обрабатывать. В таком случае нам приходится подготавливать данные в нашем приложении для дальнейшей работы с ними.
            </Text>
            <Text>В следующей части мы рассмотрим тип связи “многие ко многим”.</Text>

        </>
    )
}

export default OneToManyPage1
